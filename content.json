{"pages":[],"posts":[{"title":"Binary search algorithm","text":"In this post, I will give a brief summary of binary search algorithm, together with some programming problems on this topic. Algorithm Introduction It is a simple recursive searching algorithm. Scope of application: in ordered arrays The pseudo code1 is as follows: 123456789101112131415161718Procedure binary_search A ← sorted array n ← size of array x ← value to be searched Set lowerBound = 1 Set upperBound = n while x not found if upperBound &lt; lowerBound EXIT: x does not exists. set midPoint = lowerBound + ( upperBound - lowerBound ) / 2 if A[midPoint] &lt; x set lowerBound = midPoint + 1 if A[midPoint] &gt; x set upperBound = midPoint - 1 if A[midPoint] = x EXIT: x found at location midPoint end while In plain words, it recursively check whether the mid point value is the target, if the target is bigger, check the left half; if the target is smaller, check the right half. Complexity Space complexity Only constant number of variables are used, therefore the space complexity is $O(1)$. Time complexity Because each time after search, half of the array would be ‘discarded’, therefore the overall complexity is $O(\\log n)$, where $n$ is the length of the array. Java Implementation example123456789101112131415161718// Java - Non-recursive versionclass Solution{ public int binarySearch(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; // Prevent add overflow if (nums[mid] == target) return mid; if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; }} 12345678910111213// Java - Revursive versionclass Solution{ public int binarySearch(int[] nums, int start, int end, int target) { if (start &gt; end) return -1; int mid = start + (end - start)/2; // Prevent add overflow if (arr[mid] &gt; target) return binarySearch(arr, start, mid - 1, target); if (arr[mid] &lt; target) return binarySearch(arr, mid + 1, end, target); return mid; }} Questions Leetcode 704 - Binary search - Basic implementation for this algorithm. Leetcode 278 - First bad Version - Variation on look-up standards. Leetcode 34 - Find First and Last Position of element in Sorted array - Variation on look-up standards and re-use of code. Leetcode 33 - Search in rotated sorted array- Variation on the structure of array. Leetcode 74 - Search a 2D matrix - Variation on the structure of input array, need to reduce the dimension of input. Leetcode 162 - Find peak element - Another realization of binary search algorithm. 1.The pseudo code is derived from tutorials point ↩","link":"/2021/09/11/Binary%20search%20algorithm%20Summary/"},{"title":"Blog Plan for 2022","text":"In this article, I will outline my plan for this blog in year 2022. SummaryFor the past few months, I have been busy finishing coursework in school and preparing application materials for masters. As the application procedure draw to their deadlines, together with a new semester with less courses, a lot free time could be expected. To make use of those free time and be organized in blogging, I uploaded this blog plan to motivate myself writing and sharing my ideas both in computer science field and other interesting fields I encountered. It could also be used to track my progress during next year. Below are tasks in different areas. Some may be added or modified due to technical difficulty or change of mind. Blog constructionI would like to outline a few tasks to advance my blog’s functionalities: Add RSS feeds Add share link Support different languages (Chinese and English sites) Tags &amp; Categories construction SEO (Search engine optimization) design … ContentI would like to upload some series of articles to share my ideas in different areas. I will update this plan regularly to add links to finished articles. Computer scienceAs a computer science student, it is natural to record the knowledge learnt and organize them in a way for future review. I am planning to focus on below topics in the following year: Algorithms &amp; Data structures Articles about this topic should serve as cheat sheet when preparing for technical interviews. I will try to combine typical problems using different algorithms and data structures with theoretical knowledge. Machine learning &amp; Artificial Intelligence Articles on this topic could be: concept/algorithm definition, practical example, literature review, collected resources, etc. Database &amp; SQL Knowledge about SQL in particular could be forgotten if not used regularly. I would like to record some basic grammars for SQL and some concepts in database management. Notes in past four years As I am graduating from computer science program, I find it necessary and valuable to review the courses and the notes I took. Self-managementExcept for professional knowledge, I would like to share ideas about how I managed myself. It would cover the topic of time management, task management, information management, knowledge management, etc. Topics like software choice, workflows, general methodologies could also be expected. BookI would like to share the books I read and the notes I took. Books to share notes: How to Take Smart Notes One Simple Technique to Boost Writing, Learning and Thinking - For Students, Academics and Nonfiction Book Writers by Sönke Ahrens Getting Things Done The Art of Stress-Free Productivity Penguin by David Allen Books to read: Algorithms by Robert Sedgewick &amp; Kevin Wayne … TimelineFor blog construction tasks, I would like to complete them before February. And for the topics of computer science field, I would be uploading articles regularly across all year. And for the first two topics, I see the majority of work done by July. As for self-management and book sharing, I would be uploading articles when I think a mature idea was formed to be shared and discussed.","link":"/2021/12/29/Blog-Plan-for-2022/"},{"title":"How to set up a hexo blog","text":"In this article, you will find how to set up a hexo blog and deploy it. Special thanks to Codesheep’s video 0. Pre-requisiteThe most important of all, don’t be afraid of making mistakes! To initiate your blog, you will need the libraries below. 0.1 Node.js Download here - suggest LTS version To check whether Node.js was downloaded successfully, type node -v in the terminal window. If something like v12.18.2 is presented with no error message, you are free to go for the next step. For Windows users, terminal could be invoked by pressing win + R, and then type cmd in the prompt window. 0.2 npmnpm is the default package management tool for Node.js. For Chinese users, you could switch to the mirror in cnpm for faster downloads. Run the command to install cnpm: 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org Similar to Node.js, type npm -v to check if it’s installed successfully. 0.3 Gitgit is a version control tool used widely among programming projects. Generally speaking, it could help you keep different versions of your project. Download here To configure the git globally, you could run the command after installation. In the command, --global would set the following parameters for all git repositories on your computer. 12$ git config --global user.name &quot;Your Namee&quot;$ git config --global user.email &quot;email@example.com&quot; 0.4 hexoWith the package management tool installed, fetch the hexo package using command: 1$ npm install -g hexo or: 1$ cnpm install -g hexo Similar to Node.js, type hexo -v to check if it’s installed successfully. 1. Initiate blog Create a folder 1$ mkdir blog By default, this blog/ folder will be created in /Users/YourUserName/ for both Mac and Windows users. Navigate into the folder 1$ cd blog To check if you are in the right folder, type pwd to check. Initiate your blog ==Make sure you are in the right folder before running command below!== 1$ sudo hexo init The sudo parameter refers to admin access. Run your blog! 1$ hexo s By default, you will see the blog running at http://localhost:4000 2. Create a new articleAs indicated in the default blog file helloworld.md, you could use the command below to create a new blog. 1$ hexo n &quot;Your artical title&quot; By default, it will be created in source/_posts folder. For markdown reference, please check here. After writing, use the following command to clean the database and generate static files for local blog. 123$ hexo clean$ hexo generate$ hexo server Vist the default link again, you could see the article you just wrote. 3. Deploy your blog You will need a Github account or Gitee accound for deployment. Github Create a new repository with the name YourFullUserName.github.io and it has to be set to public. Install a plugin for deployment. 1$ npm install --save hexo-deployer-git Find the _config.yml file in your blog folder, at the end of this file, modify the following content: 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: Your Github repo's link branch: master Your repo link should end with .github.io.git which you could obtain here. After saving your config file, run command below to deploy your blog. 1$ hexo d You may need to type your user name and password. See you blog online! Visit yourUserName.github.io Gitee#TODO References Codesheep’s video in Chinese","link":"/2021/11/28/How-to-set-up-a-hexo-blog/"},{"title":"Index System Introduction","text":"In this article, you will find an brief definition of Index system, how is it useful and how to build one on your own. Further to my internship experience and my reading on the web, I have concluded some information about index system. 1. What is Index System?For example, when deciding whether a company is worth investing, you would see comments like “This company has too much loans”, “It is not making any profits”. However in data-driven industries (like finance), you need to support your decisions with intuitive evidence. Instead of raw business data, an index should be used for demonstration purposes (e.g. Asset-liability ratio).In the above example, the index of asset-liability ration addresses the company’s debt. In real world problem, complicate problem could not be resolved by using one single index (e.g. Evaluating a company’s future profitability), therefore a set of indexes is needed to describe the data subject from different perspectives and lead to a informed decision, that is where index system plays a role. 2. How is index system useful?When evaluating one’s health condition, we tend to use the indicators like body fat percentage, body temperature, blood pressure, etc. Considering these indicators together, one’s health status could then be determined. It’s the same when using index system to evaluate a company. When something goes wrong, the index system should be able to reflect this abnormality. Tracing down the problematic index that goes wrong, the current problem in business should be clear. And then the relevant department could have the right direction to improve on. In summary, the index system should achieve the following: Monitor business situation Find problems based on problematic index Evaluate business and guide the future work. 3. How to build an index system?The general approach is as following: Understand company’s / department’s Key Performance Indicator (KPI), define Level-1 Index Understand the business, dismantle Level-1 Index and define Level-2 Index Sort out business processes, dismantle Level-2 Index and define Level-3 Index Using reports to monitor index system, update it accordingly 4. Common mistakes when building index system Not understand the KPI No logic relationship between indexes Dissembled indexes has no business meaning Little or No communication between data department and business department Reference Zhihu’s passage - How to build an index system by Houzi","link":"/2021/09/27/Index%20System%20Introduction/"},{"title":"Intention of this blog","text":"Aims Record feelings and findings during CS study. Share my project experience with reproduceble steps. Publish notes about courses and libraies. To be continued…With more posts, this article will serve as an index page.","link":"/2021/08/18/Intention-of-this-blog/"},{"title":"Introduction to Cryptography","text":"In this piece of notes, I will give an overview of Crypotography, introduce basic principles and algorithms for symmetric cryptography, assymetric cryptography and Protocols. Structure of Cryptography Symmetric Cryptography Same key for encryption and decryption Ensures confidentiality Implemented via block ciphers or stream ciphers Lightweight and fast Used for general communication Stream CiphersImplementation Initial seed key to generate an infinite keystream of random bits Using same keystream to encrypt two messages -&gt; easy to break A random “number used once” ( nonce ) added as additional seed -&gt; ensure keystream is new Message &amp; keystream combined using XOR to get the cipher text ==XOR is reversible is applied twice==, which brings much convenience when decrypt cipher text. Advantages Encrypting long continuous streams, possibly of unknown length Extremely fast with a low memory footprint, ideal for low-power devices If designed well, can seek to any location in the stream Disadvantages The keystream must appear statistically random You must *never* reuse a key + nonce Stream ciphers do not protect the ciphertext Therefore, message could be manipulated during transition without breaking confidentiality E.g., suppose you are transmitting a message to bank saying A owes you $50. Attacker could either manipulate the amount or the creditor using the same stream ciper or resent the same message to server. Block CipersImplementation Use a key to encrypt a fixed-size block of plaintext into a fixed-size block of ciphertext Changing and permuting the bits of the block depending on the key Different lengths of messages can be handled by splitting the message up and padding Example - SP-NetworksWiki Repeated substitution and permutation Key mixing for enhancing security -&gt; Different key for different round Decipher = Reverse operation Symmetric Algorithms Algorithm Cipher Type Design Block Size (bits) Speed Memory Footprint Safe Implementation Difficulty Key Sizes (bits) DES Block Feistel 64 Fast Low Easy 56 3DES Block Feistel 64 Slow Low Easy 112 AES Block SP-Network 128 Very fast Low-Medium Hard 128/192/256 ChaCha20 Stream add-xor-rot N/A Very fast Very low Easy 256 Asymmetric Cryptography Use a pair of keys, one public and one private Public-key cryptographyGeneral Idea Hinges upon the premise that: It is computationally infeasible to calculate a private from a public key In practice, it is achieved through intractable mathematical problem Key exchange Diffie-Hellman Key exchange allows two parties to mathematically agree a shared secret over an insecure channel Alice and Bob each uses a public non-reversible Generator with their private keys to generate public key and send it to each other. Using other’s public key and self’s private key, shared secret could be established. Public Key Encryption Encryption performed by the public key can only be reversed using the private key Digital Signatures The authenticity of signatures generated by the private key can by verified by the public key Steps Server send the original message Server use private key to encrypt Server send the encrypted message User verify using public key Public Key Algorithms Algorithm Key Exchange Encryption Digital Signatures Mathematical Problem Elliptic Curves? Typical key Size (bits) Diffie-Hellman ✓ Discrete Logs ✓ 256 RSA ✓ ✓ Integer Factorisation 2048/4096 Elgamal ✓ ✓ Discrete Logs ✓ 2048 DSA ✓ Discrete Logs ✓ 256 Protocols Application of cryptographic algorithms in secure systems Hash Functions Cryptographic primitive Takes a message of any length, and returns a pseudorandom hash of fixed length Strong hash functions must appear random be hard to find collisions – two messages that hash to the same thing Hash Function usage Message Authentication Codes Provide integrity and authenticity, not confidentiality Protecting system files Ensuring messages haven’t been altered Calculate a keyed hash of the message, then append to the end of the message Digital Signatures The use of a hash during the signing process shortens the signature More efficient for long messages Password storage Passwords stored hashed to prevent disclosure","link":"/2022/02/17/Introduction-to-Crypotography/"},{"title":"OSC Lecture Notes - Introduction","text":"In this note, you could find the basic definition of Operating Systems and the general architecture of computer. Defining Operating SystemsWhat can an OS do for me? File systems: where is the file physically written on the disk and how is it retrieved? Abstraction: why looks the instruction the same independent of the device? Concurrency: what if multiple programs access the same file simultaneously? What if an other process starts running? Security: why is the access denied? Where in memory will the array be stored and how is it protected from unauthorised access? What if the array requires more memory than physically available? What if only part of the array is currently in use ? What is part of the operating system?Memory management, CPU scheduling, file system, communication, memory management, interrupt handling, GUI, . . . A resource manager Many modern operating systems use multi-programming to improve user experience and maximize resource utilization Disks are slow: without multi-programming, CPU time is wasted while waiting for I/O requests Imagine a CPU running at 3.2 GHz (approx. 3:2 $\\times$ 109 instructions per second) Imagine a disk rotating at 7200 RPM, taking 4.2 ms to rotate half a track I/O is slow, we are missing out on 3.2 $\\times$ 4.2 $\\times$ $10^6$ instructions (13.44m)! The implementation of multi-programming has important consequences for operating system design The operating system must allocate/share resources (including CPU, memory, I/O devices) fairly and safely between competing processes: In time, e.g. CPUs and printers In space, e.g., memory and disks The execution of multiple programs (processes) needs to be interleaved with one another: This requires context switches and process scheduling ) $\\Rightarrow$ mutual exclusion, deadlock avoidance, protection, . . OriginIn the early days, programmers had to deal directly with the hardware Real computer hardware is ugly Hardware is extremely difficult to manipulate/program ==An operating system is a layer of indirection on top of the hardware==: It provide abstractions for application programs (e.g., file systems) It provides a cleaner and easier interface to the hardware and hides the complexity of “bare metal” It allows the programmer to be lazy by using common routines :-) Why study operating system? The programs that we write use operating system functionality How are the operating system’s services/abstractions implemented Computer Architecture Simplified computer model (Tanenbaum, 2014) CPU design CPU’s basic cycle consist of fetch, decode, and execute (pipelines, or superscalar) Every CPU has his own instruction set A CPU has a set of registers (extremely fast memory close to the CPU “core”) Registers are used to store data and for special functions (e.g. program counter, program status word – mode bit) The compiler/programmer decides what to keep in the registers Context switching must save and restore the CPU’s internal state, including its registers Memory management Unit There are two different address spaces: the logical address space seen by the process and used by the compiler the physical address space seen by the hardware/OS When compiling code, memory addresses must be assigned to variables and instructions, the compiler does not know what memory addresses will be available in physical memory It will just assume that the code will start running at address 0 when generating the machine code On some rare occasions, the process may run at physical address 0 physical address = logical address + 0 On other occasions, it will be running at a completely different location in physical memory and an offset is added physical address = logical address + offset The memory management unit(MMU) is responsible for address translation (“adding the offset”) Different processes require different address translation (offsets) Context switching requires the MMU to be updated (and registers, cache, …) Example1234567891011#include &lt;stdio.h&gt;int iVar = 0;void main() { int i = 0; while(i &lt; 10) { iVar++; sleep(2); printf(&quot;Address:%u; Value:%d\\n&quot;,&amp;iVar, iVar); i++; }} The same addresses will be displayed for iVar. The address printed on the screen is the logical address The value for iVar in the first run doesn’t influence the second run’s value Moore’s Law “The number of transistors on an integrated circuit (chip) doubles roughly every two years” Closely linked, but not necessarily related to performance Moore’s still continuing, but the “power wall” slows performance improvements of single core/single processor systems A few cores for multiple “programs” is easy to justify How to use massively parallel computers/CPUs/many core machines Can we extract parallelism automatically, can we implement parallelism at the lowest level (similar to multiprogramming) Lead to multi-core / parallel development Multi-core, hyperthreaded processors Modern CPUs contain multiple cores and are often hyper-threaded Evolution in hardware has implications on operating system design XP did not support multi processor architectures Process scheduling needs to account for load balancing and CPU affinity Cache coherency becomes important (manage run-time data) Previous exam: Describe how, in your opinion, recent developments in computerarchitecture and computer design have influenced operating system design Timer Interrupts Interrupts temporarily pause a process’s normal operation Different types of interrupts exist, including: Timer interrupts by CPU clock I/O interrupts for I/O completion or error codes Software generated, e.g. errors and exceptions Context switches (i.e. switching between processes) can be initiated by timer interrupts after a “set time” Timer generates an interrupt CPU finishes current instruction and tests for interrupt Transfer to interrupt service routine Hardware saves current process state (PSW, program counter) Set program counter to interrupt service routine Save registers and other state information Carry out interrupt service routine (scheduler) Restore next process to run","link":"/2020/10/04/OSC%20Lecture%20Notes%20-%20Introduction/"},{"title":"Thinking about writing","text":"In this article, I will rethink the importance of writing, and discuss how the tools I used evolved. Motivation In information era, the way we express ourselves matters. Different thinking pattern could be reflected from the writing. Among applications, we could use the most efficient way to express and organize our ideas. The importance of writingWriting, in its board aspect, is an everyday activity for all of us. However, according to my friends, little of us have ever thought carefully about this activity. Different format we use could help us train different thinking patterns. Different applications we chose could effect the efficiency of expressing ourselves and organizing ideas. It is also an important way for us to exchange serious opinions in a decent manner (like publications). Different format could be applied to writing. Within my knowledge, they are plain text (.txt, .word files), hypertext (.html, .md files) and outline (.opml files). Each format has an implication of different thinking pattern. For example, if you use outlining more often than other format, you are tend to be a person with a good sense of the overall picture.If you use hypertext (e.g. markdown) very often, you tend to care about the content more than the format it is presented. In Sönke Ahrens’s book , he emphasis the importance of writing: An idea kept private is as good as one you never had. And a fact no one can reproduce is no fact at all. Making something public always means to write it down so it can be read. There is no such thing as a history of unwritten ideas. My experience in writingDuring my early life, I used Microsoft Word as my main editing tool as this is the only one I am familiar with. The software works fine, however, as I grow older, I tend to realize that I spend a lot of time editing the format for different headings and emphasis. With my exploartion in computer science, I started to use markdown as the main form of many writings. Markdown is a kind of mark up language, which uses a small set of symbols to realize the formatting. This freed me from doing manual adjustment for different parts of the text and could now focus more on the content. Markdown is also a portable format. The formatting is realized by limited symbols which allows the raw text to be readable.In my university, I have been using markdown to take notes, write reports and draft my dissertation. Though markdown itself is a powerful concept, the editor could be of great add on to this kind of writing. I have tried a lot of different markdown editors and now kept mainly two of them (Typora and Obsidian), I will write more about the reasoning of choices I made in a later post. As my writing in markdown format increases, I started to realize one drawback for this format. It is more of a connstraint in its methodology rather than software design. Markdown kinds of suggest a fragmented thinking, where each piece of markdown note stands for a concept or event solely. Though markdown provides link feature, it is not good for getting the whole picture (say you are taking notes for a course and want to have an overview before exam). This let me to another kind of writing - outlining. Compared to putting emphasis on the details, outline writing put an emphasis on the key points or the main topic. It encourages concise language choices which is helpful for letting you know the bigger picture and the key points. Using the outlining tools together with my markdown notes, I could both get an general understanding and have detailed information when refering to my notes. Later when I came accross the PKM concept, I began to use Obsidian to manage my markdown notes, which could provide two-way linking between different files. How I implemented my own PKM system using Obsidian could be found in another post.","link":"/2022/02/09/Thinking-about-writing/"},{"title":"Thinking about Time management","text":"In this article, I will talk about my understanding and implementation of time management measures. Moreover, I would introduce some popular concepts of this topic, like GTD, Pomodoros,The Eisenhower Method. Understanding of Time management What it is? What’s its importance? Time management is the process of carefully planning time individuals spent on various activities. The aim of the time management is to increase efficiency and productivity. For a simple example, suppose you need to prepare dinner for your family, you need to complete a set of tasks like shopping for groceries, preparing ingridients, cooking, etc. Time management skills tend to help you reduce the overall time spent on all this tasks by arranging them consciously. In computer science, the design of operating system provides an abstraction on this topic via CPU scheduling. The priorities of tasks resembles the real life situation where some tasks is more urgent than others. The overhead of context switch (switching between tasks) is a vivid abstraction of human changing focus. For a difficult task (takes more time), it was split into more time slices to complete. Popular ConceptsThe Eisenhower MethodIt is a method that utilizes the criteria of importance and urgency to organize priorities and workload. Based on the two criteria, tasks could be categorized into four categories (as in following graph) Important &amp; Urgent tasks - should be done immediately and in person. Important &amp; Not Urgent tasks - should be done at certain dates and in person. Unimportant &amp; Urgent tasks - could be delegated. Unimportant &amp; Not Urgent tasks - should be dropped. In practice, it is not frequently listed but used as a mental model to decide the task’s properties. PomodorosThis method was originally from Francesco Cirillo’s Pomodoro Technique. It took the name from a Pomodoro - tomato shaped kitchen timer. The “Pomodoro” is defined as the fundamental unit of time to measure tasks’ expected completion time, which is traditionally defined as being 30 minutes long, consisting of 25 minutes of work and 5 minutes of break time. Though it may seems stiff to use strict pomodoros, it could actually develop your sense of time and help you record your performance. With continuous using of this technique, you could be more confident in predicting tasks’ completion time. Recoding how many Pomodoros you finished could also be a straight forward metric of evaluating your performance. GTDThis strategy was created by David Allen in his book Getting Things Done. The basic idea of this strategy is to capture all unfinished things (projects or tasks), clarify them into small actionable tasks with clear goals, organize them in appropriate forms (and come up to you at proper time), review tasks frequently to update the status and engage in these tasks. In general, it provides a complete workflow for you to manage all your tasks and projects in a personalized system. Though this system may be hard to build and maintain, from my own experience, it is worthwhile to keep you confident in action decisions. My implementation of time managementTo start with your time mangement, you frist need to be aware of where you spent your time. I used aTimeLogger to track my everyday activities. This is the start of my time management practice and could provide a clear view of whether you are hard working or playing too much. You could also pick your own time tracking app, just pay attention to the philosophy of the software to make sure they are NOT interruptive of your current activities and time-consuming when recording. To plan your time carefully and wisely, I used GTD techniques to track all the tasks I need to finish and all the events I need to participate. Following GTD’s principles, I would tag the tasks with its expected context (when would be proper, what tools needed, etc.) and group them with the assoicated project. I have tried plenty of task management apps like Omnifocus (which I am now using), Things 3, TickTick (Used for a long time), Wunderlist, etc. It is hard to give a general suggestion for the choice as different people may have different requirements, just make sure the app you choose helps record your tasks easily, intergrate nicely with your workflow and remind you in appropriate format. One more thing to care about, is DO NOT overmanaging. I had once fallen into the pitfall of overmanaging myself. I enjoyed listing and categorizing different tasks and projects, trying different apps, perfecting the tag system but just NOT complete many of those tasks. Remember what the name suggest, getting things done, so focus on completing the tasks rather than putting most of your efforts changing their organization. In the new information era, another thing has become more valuable than our time, that is, our attention (or effective time). The power of attention has long been discovered by physicist through Double-slit experiment, in which whether observer exists could impact the results of the inference pattern. Modern business are even using our attention to gain money (through online advertisement). We need to pay attention to what we paid our attention to. What you should do, is paying attention to the four things below: focusing on valuable things relationships, especially intimacy finding new trends Self development Pomodoros is therefore been introduced to my system to record my attention (though it has way more potentials as introduced above). You could easily track your progress and performance via pomodoro recoding. I am now using Session as the app to record for its elegant visualizations and ease of use.","link":"/2022/02/16/Thinking-about-time-management/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/17/hello-world/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"translation","slug":"translation","link":"/tags/translation/"},{"name":"Cryptography","slug":"Cryptography","link":"/tags/Cryptography/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Methodology","slug":"Methodology","link":"/tags/Methodology/"},{"name":"Writing","slug":"Writing","link":"/tags/Writing/"}],"categories":[{"name":"Computer science","slug":"Computer-science","link":"/categories/Computer-science/"},{"name":"Data Science","slug":"Data-Science","link":"/categories/Data-Science/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Informal Essays","slug":"Informal-Essays","link":"/categories/Informal-Essays/"}]}